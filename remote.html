<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nextamp Remote Upload</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        background-color: #050505;
        color: #00ff00;
        font-family: "Chakra Petch", sans-serif;
      }
      .win-btn {
        background: #c0c0c0;
        color: black;
        border: 2px solid #fff;
        border-right-color: #000;
        border-bottom-color: #000;
        cursor: pointer;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.1s;
      }
      .win-btn:active {
        border-color: #000;
        border-right-color: #fff;
        border-bottom-color: #fff;
        transform: translate(1px, 1px);
      }
      .win-btn:disabled {
        background: #555;
        color: #888;
        border-color: #444;
        cursor: not-allowed;
        transform: none;
      }
      /* Custom Scrollbar for Modal */
      .custom-scroll::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scroll::-webkit-scrollbar-track {
        background: #111;
      }
      .custom-scroll::-webkit-scrollbar-thumb {
        background: #333;
        border-radius: 4px;
      }
      .custom-scroll::-webkit-scrollbar-thumb:hover {
        background: #555;
      }
    </style>
  </head>
  <body
    class="flex flex-col items-center justify-center min-h-screen p-4 space-y-6 select-none"
  >
    <div class="text-center space-y-2">
      <h1 class="text-3xl font-bold text-white tracking-widest">
        NEXTAMP <span class="text-[#00ff00]">REMOTE</span>
      </h1>
      <div id="connection-status" class="text-xs text-gray-400 font-mono">
        Initializing...
      </div>
    </div>

    <div id="main-interface" class="w-full max-w-sm flex flex-col gap-6 hidden">
      <input
        type="file"
        id="file-input"
        accept="audio/*,.mp3,.wav,.m4a,.ogg"
        multiple
        class="hidden"
      />

      <div class="flex flex-col gap-4">
        <button
          id="btn-select"
          onclick="document.getElementById('file-input').click()"
          class="win-btn w-full py-6 text-xl shadow-[0_0_15px_rgba(0,255,0,0.2)] flex flex-col items-center gap-1"
        >
          <span>SELECT FILES</span>
          <span class="text-[10px] font-normal text-gray-700"
            >(Device Storage)</span
          >
        </button>

        <button
          id="btn-library"
          onclick="openLibraryModal()"
          class="win-btn w-full py-4 text-lg bg-[#a0a0a0] flex flex-col items-center gap-1"
        >
          <span>SELECT FROM LIBRARY</span>
          <span class="text-[10px] font-normal text-gray-700"
            >(Nextamp Database)</span
          >
        </button>
      </div>

      <div class="text-center text-[10px] text-gray-500">
        Max 10 files per transfer
      </div>

      <div
        id="queue-info"
        class="text-center text-xs text-gray-400 hidden font-mono"
      >
        QUEUE: <span id="queue-count" class="text-white font-bold">0/0</span>
      </div>

      <div
        id="progress-area"
        class="bg-[#111] border border-[#333] p-4 rounded hidden"
      >
        <div class="flex justify-between text-xs mb-1 font-mono">
          <span id="filename-disp" class="truncate max-w-[200px] text-white"
            >...</span
          >
          <span id="percent-disp">0%</span>
        </div>
        <div class="w-full bg-[#333] h-2 border border-gray-600">
          <div
            id="progress-bar"
            class="h-full bg-[#00ff00] w-0 transition-all duration-75"
          ></div>
        </div>
        <div
          class="text-[10px] text-gray-500 mt-2 text-center"
          id="status-detail"
        >
          Waiting...
        </div>
      </div>
    </div>

    <div
      id="lib-modal"
      class="fixed inset-0 bg-black/90 z-50 hidden flex flex-col items-center justify-center p-4"
    >
      <div
        class="bg-[#111] border border-[#333] w-full max-w-sm rounded-lg flex flex-col max-h-[80vh] shadow-[0_0_30px_rgba(0,255,0,0.1)]"
      >
        <div
          class="p-4 border-b border-[#333] flex justify-between items-center bg-[#1a1a1a] rounded-t-lg"
        >
          <h2 class="text-white font-bold tracking-wider">SELECT TRACKS</h2>
          <span id="lib-count-disp" class="text-xs text-[#00ff00] font-mono"
            >0/10</span
          >
        </div>

        <div
          id="lib-list"
          class="flex-1 overflow-y-auto p-2 space-y-1 custom-scroll bg-[#050505]"
        >
          <div class="text-center text-gray-500 py-8 text-xs">Loading...</div>
        </div>

        <div
          class="p-4 border-t border-[#333] flex gap-3 bg-[#1a1a1a] rounded-b-lg"
        >
          <button
            onclick="closeLibraryModal()"
            class="win-btn flex-1 py-3 text-sm"
          >
            CANCEL
          </button>
          <button
            onclick="confirmLibrarySelection()"
            class="win-btn flex-1 py-3 text-sm text-[#006600] font-bold"
          >
            SEND SELECTED
          </button>
        </div>
      </div>
    </div>

    <script>
      // CONFIG
      const CHUNK_SIZE = 16 * 1024; // 16KB per chunk
      const SYNC_INTERVAL = 20;
      const LIMIT_MAX_FILES = 10;
      const LIMIT_MAX_SIZE_MB = 100;
      const DB_NAME = "NextampUltimateDB";

      const params = new URLSearchParams(window.location.search);
      const hostId = params.get("host");

      const statusEl = document.getElementById("connection-status");
      const mainInterface = document.getElementById("main-interface");
      const btnSelect = document.getElementById("btn-select");
      const btnLibrary = document.getElementById("btn-library");
      const progressArea = document.getElementById("progress-area");

      let peer = null,
        conn = null;
      let fileQueue = [],
        totalFiles = 0;
      let isProcessing = false;

      // Variables for Library Feature
      let libFilesCache = [];

      // Variables for Sync
      let resolveUpload = null;
      let resolveSync = null;

      if (!hostId) {
        statusEl.innerText = "Error: Invalid Link";
        statusEl.className = "text-xs text-red-500 font-mono";
        throw new Error("No Host ID");
      }

      peer = new Peer();

      peer.on("open", (id) => {
        statusEl.innerText = "Connecting...";
        conn = peer.connect(hostId, { reliable: true });

        conn.on("open", () => {
          statusEl.innerText = "CONNECTED: Ready";
          statusEl.className = "text-xs text-[#00ff00] font-mono";
          mainInterface.classList.remove("hidden");
        });

        conn.on("close", () => {
          statusEl.innerText = "Disconnected.";
          statusEl.className = "text-xs text-red-500 font-mono";
          btnSelect.disabled = true;
          btnLibrary.disabled = true;
          mainInterface.classList.add("opacity-50");
        });

        conn.on("data", (data) => {
          if (data.type === "file_received") {
            if (resolveUpload) resolveUpload();
          } else if (data.type === "sync_ack") {
            if (resolveSync) resolveSync();
          }
        });
      });

      // --- File Input Handling ---
      document.getElementById("file-input").addEventListener("change", (e) => {
        const files = Array.from(e.target.files);
        handleNewFiles(files);
        e.target.value = ""; // reset
      });

      function handleNewFiles(files) {
        if (files.length === 0) return;
        if (files.length > LIMIT_MAX_FILES)
          return alert(`Max ${LIMIT_MAX_FILES} files.`);

        const validFiles = files.filter(
          (f) => f.size / 1024 / 1024 <= LIMIT_MAX_SIZE_MB
        );
        if (validFiles.length === 0)
          return alert("Files too large or invalid.");

        fileQueue = validFiles;
        totalFiles = validFiles.length;
        processQueue();
      }

      // --- Library Handling ---
      async function openLibraryModal() {
        if (isProcessing) return;

        try {
          const files = await getLibraryFiles();
          if (!files || files.length === 0) {
            return alert("No tracks found in Nextamp Library on this device.");
          }

          libFilesCache = files;
          renderLibraryList();
          document.getElementById("lib-modal").classList.remove("hidden");
        } catch (e) {
          console.error(e);
          alert("Could not access library database.");
        }
      }

      function closeLibraryModal() {
        document.getElementById("lib-modal").classList.add("hidden");
        libFilesCache = [];
      }

      function getLibraryFiles() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 8); // Same version as app.js

          req.onerror = () => reject("DB Open Error");

          // If DB doesn't exist, this triggers. We don't want to create it here.
          req.onupgradeneeded = (e) => {
            e.target.transaction.abort();
            resolve([]);
          };

          req.onsuccess = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains("library")) {
              db.close();
              return resolve([]);
            }
            const tx = db.transaction("library", "readonly");
            const store = tx.objectStore("library");
            const getAll = store.getAll();

            getAll.onsuccess = () => {
              resolve(getAll.result);
              db.close();
            };
            getAll.onerror = () => {
              reject("Read Error");
              db.close();
            };
          };
        });
      }

      function renderLibraryList() {
        const list = document.getElementById("lib-list");
        list.innerHTML = "";

        libFilesCache.forEach((item, idx) => {
          const div = document.createElement("div");
          div.className =
            "flex items-center gap-3 p-3 hover:bg-[#222] cursor-pointer border border-transparent hover:border-[#444] rounded bg-[#0a0a0a] transition-colors";
          div.onclick = (e) => {
            if (e.target.type !== "checkbox") {
              const cb = div.querySelector("input");
              if (!cb.disabled) {
                cb.checked = !cb.checked;
                updateLibCount();
              }
            }
          };

          div.innerHTML = `
            <input type="checkbox" class="accent-[#00ff00] w-5 h-5 flex-shrink-0 cursor-pointer" value="${idx}">
            <div class="flex flex-col overflow-hidden">
              <span class="truncate text-sm text-gray-200 font-bold pointer-events-none">${
                item.name
              }</span>
              <span class="text-[10px] text-gray-500 pointer-events-none">ID: ${item.id.substring(
                0,
                8
              )}...</span>
            </div>
          `;
          list.appendChild(div);
        });
        updateLibCount();
      }

      function updateLibCount() {
        const checkboxes = document.querySelectorAll("#lib-list input:checked");
        const count = checkboxes.length;
        const countDisp = document.getElementById("lib-count-disp");

        countDisp.innerText = `${count}/${LIMIT_MAX_FILES}`;
        countDisp.classList.toggle("text-red-500", count > LIMIT_MAX_FILES);
        countDisp.classList.toggle("text-[#00ff00]", count <= LIMIT_MAX_FILES);

        // Optional: Disable unchecked inputs if limit reached
        const allChecks = document.querySelectorAll("#lib-list input");
        allChecks.forEach((cb) => {
          if (!cb.checked) {
            cb.disabled = count >= LIMIT_MAX_FILES;
            cb.parentElement.classList.toggle(
              "opacity-50",
              count >= LIMIT_MAX_FILES
            );
          } else {
            cb.disabled = false;
            cb.parentElement.classList.remove("opacity-50");
          }
        });
      }

      function confirmLibrarySelection() {
        const checkboxes = document.querySelectorAll("#lib-list input:checked");
        if (checkboxes.length === 0) return;

        const selectedFiles = [];
        checkboxes.forEach((cb) => {
          const idx = parseInt(cb.value);
          const item = libFilesCache[idx];
          if (item && item.blob) {
            let file = item.blob;

            // Ensure the file has the correct name (IndexedDB blobs might lose name)
            try {
              // Try to construct a new File object to ensure name is correct
              file = new File([item.blob], item.name, {
                type: item.blob.type || "audio/mpeg",
              });
            } catch (e) {
              // Fallback for older environments
              console.warn("File constructor fallback", e);
              // We just use the blob, but we'll send the name manually in 'meta'
              file.name = item.name;
            }
            selectedFiles.push(file);
          }
        });

        if (selectedFiles.length > 0) {
          closeLibraryModal();
          handleNewFiles(selectedFiles);
        }
      }

      // --- Processing Queue ---

      async function processQueue() {
        if (isProcessing) return;
        isProcessing = true;
        btnSelect.disabled = true;
        btnLibrary.disabled = true;
        progressArea.classList.remove("hidden");
        document.getElementById("queue-info").classList.remove("hidden");

        for (let i = 0; i < fileQueue.length; i++) {
          const file = fileQueue[i];
          document.getElementById("queue-count").innerText = `${
            i + 1
          }/${totalFiles}`;
          try {
            await sendFileRobust(file);
          } catch (err) {
            console.error(err);
            alert(`Error sending ${file.name || "file"}`);
          }
        }

        isProcessing = false;
        btnSelect.disabled = false;
        btnLibrary.disabled = false;
        btnSelect.innerText = "SEND MORE";
        document.getElementById("status-detail").innerText = "All Done!";
        document
          .getElementById("status-detail")
          .classList.add("text-[#00ff00]");
        setTimeout(() => {
          alert("Transfer Complete!");
          progressArea.classList.add("hidden");
          document.getElementById("queue-info").classList.add("hidden");
          document
            .getElementById("status-detail")
            .classList.remove("text-[#00ff00]");

          // Reset Buttons
          btnSelect.innerHTML = `<span>SELECT FILES</span><span class="text-[10px] font-normal text-gray-700">(Device Storage)</span>`;
        }, 500);
      }

      function sendFileRobust(file) {
        return new Promise((resolve, reject) => {
          if (!conn || !conn.open) return reject("No connection");

          // Ensure name exists (fallback if File object lost it)
          const fileName = file.name || "unknown_audio.mp3";

          document.getElementById("filename-disp").innerText = fileName;
          document.getElementById("status-detail").innerText = "Starting...";
          document.getElementById("progress-bar").style.width = "0%";
          document.getElementById("percent-disp").innerText = "0%";

          // 1. Send Meta
          conn.send({
            type: "meta",
            name: fileName,
            size: file.size,
            mime: file.type || "audio/mpeg",
          });

          let offset = 0;
          let chunkCount = 0;
          const reader = new FileReader();

          reader.onload = async (event) => {
            try {
              const chunk = event.target.result;
              conn.send(chunk);
              offset += chunk.byteLength;
              chunkCount++;

              await new Promise((r) => setTimeout(r, 10));

              // UI Update
              const percent = Math.round((offset / file.size) * 100);
              document.getElementById("progress-bar").style.width =
                percent + "%";
              document.getElementById("percent-disp").innerText = percent + "%";

              if (chunkCount % SYNC_INTERVAL === 0) {
                document.getElementById("status-detail").innerText =
                  "Syncing...";
                conn.send({ type: "sync" });
                await waitForSync();
                document.getElementById("status-detail").innerText =
                  "Sending...";
              }

              if (offset < file.size) {
                readNextChunk();
              } else {
                document.getElementById("status-detail").innerText =
                  "Verifying...";
                conn.send({ type: "end" });
                resolveUpload = resolve;
              }
            } catch (e) {
              reject(e);
            }
          };

          const readNextChunk = () => {
            const slice = file.slice(offset, offset + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
          };

          const waitForSync = () => {
            return new Promise((r) => {
              resolveSync = r;
            });
          };

          readNextChunk();
        });
      }
    </script>
  </body>
</html>
